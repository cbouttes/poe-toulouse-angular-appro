<h1>Communication entre les composants</h1>

<section>
  <h2>Les Attributs de composant et Typescript</h2>

  <p>Lorsqu'on d√©clare un attribut dans un composant, sans l'initialiser, typescript peut g√©n√©rer une erreur de compilation.</p>
  <p>Exemple : </p>
  <p><code>produit : string;</code></p>
  <p>Ici, on d√©clare une propri√©t√© produit de type string, sans l'initialiser √† la d√©claration ni dans le constructor.</p>
  <p>Hors, une variable non initialis√©e est <i>undefined</i>, et undefined, c'est un type.</p>
  <p>Donc ici, typescript r√¢le parce que le typage n'est pas bon, string !== undefined;</p>
  <p>Pour pallier √† √ßa, il existe plusieurs solutions : </p>
  <ul>
    <li>Initialiser la valeur avec une valeur par d√©faut, si possible.</li>
    <li>Le typer en undefined : <code>produit: string | undefined;</code></li>
    <li>Le rendre optionnel : <code>produit? : string;</code></li>
    <li>Le rendre "obligatoire" : <code>produit! : string;</code></li>
  </ul>
  <p>(cf : commentaires dans le composant components/enfant.component.ts )</p>
</section>

<section>
  <h2>La communication descendante : Props</h2>
  <p>Passer une information d'un composant parent vers un composant enfant.</p>

  <p>Lorsqu'on cr√©√© un composant enfant, qui attend une valeur, on le d√©clare avec une propri√©t√© pr√©fix√© du d√©corateur
  <code>@Input() ma_propri√©t√©: type;</code></p>
  <p>On peut ensuite se servir de cette propri√©t√© √† l'int√©rieur du composant, et de son template sans avoir √† ce soucier
  de ce qu'elle contient ( il faut juste conna√Ætre son / ses types possible.</p>

  <p>Du c√¥t√© du parent, on passe la valeur souhait√© dans la balise du composant enfant, via un attribut de balise du
    m√™me nom que l'Input d√©clar√© ( <code>{{ '<' + 'app-enfant' + ' ma_propri√©t√©="valeur"' + '>'}}</code></p>

  <p>Cette propri√©t√© suit les m√™mes r√®gles que les autres attributs HTML : entour√©e de crochets [], elle interpr√©te du JS.</p>

  <p>Un enfant peut attendre plusieurs inputs.</p>

  <p>Pour cr√©er un input obligatoire, plusieurs solutions : </p>
  <ul>
    <li>Tester la pr√©sence de la valeur dans le ngOnInit, et si elle est vide, lancer une erreur. -> Erreur interpretation dans le navigateur</li>
    <li>Ajouter le ou les inputs obligatoire dans le selector du composant enfant : <code>selector : 'app-enfant[produit]'</code> -> Lance une erreur de compilation, dans le terminal</li>
  </ul>

  <h3>Mes produits</h3>

  <p><b>Produits dans parent : </b>
    {{products.join(' ,')}}
  </p>

  <div class="grid">
    <!--
    <app-enfant produit="Bottes √† moumoute"></app-enfant>
    <app-enfant [produit]="pantoufle"></app-enfant>
    -->
    <app-enfant *ngFor="let p of products; let i = index;" [produit]="p" (update_event)="handleUpdateEvent($event, i)"></app-enfant>
  </div>


</section>

<section>
  <h2>Compteur</h2>
  <p><i>[parent] : Valeur de parent count {{parent_count}}</i></p>
  <button (click)="plus()">[parent]</button>

  <div class="grid">
    <app-counter [count]="parent_count" (update_event)="updateCounter($event)"></app-counter>
  </div>
</section>


<section>
  <h2>Compteur en short ü©≥ </h2>
  <p><i>[parent] : Valeur de parent count {{parent_count_2}}</i></p>

  <p>En appelant le Output du composant enfant en suivant la syntaxe nominputChange ( ici <i>countChange</i> ),
  on permet √† Angular de g√©rer la modification des donn√©es de mani√®re bidirectionnelle ( <b>Two Way Binding</b> ).</p>
  <p>√ßa ne fonctionne pas dans une ngFor, √ßa ne fonctionne que quand l'input pass√© est directement la valeur enregistr√©e dans le parent.</p>

  <div class="grid">
    <app-counter-short [(count)]="parent_count_2" ></app-counter-short>
  </div>
</section>
